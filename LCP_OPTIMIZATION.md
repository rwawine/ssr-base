# Оптимизация LCP (Largest Contentful Paint)

## Обзор

LCP (Largest Contentful Paint) - это один из ключевых метрик Core Web Vitals, который измеряет время, необходимое для отображения самого большого элемента контента на странице. Для изображений LCP можно разбить на четыре части:

## Четыре части LCP для изображений

### 1. Время до первого байта (TTFB - Time to First Byte)
**Описание**: Время с момента начала загрузки страницы до получения первого байта HTML-документа.

**Оптимизации в проекте**:
- ✅ Настроены HTTP заголовки для кэширования
- ✅ Используется Next.js с оптимизированной серверной отдачей
- ✅ Настроены DNS prefetch и preconnect для внешних доменов

**Дополнительные рекомендации**:
- Использовать CDN для статических ресурсов
- Оптимизировать серверную логику
- Минимизировать размер HTML

### 2. Задержка загрузки (Resource Load Delay)
**Описание**: Разница между TTFB и моментом, когда браузер начинает загрузку ресурса LCP.

**Оптимизации в проекте**:
- ✅ Предзагрузка критических изображений через `preloadCriticalImages()`
- ✅ Использование `priority={true}` для LCP изображений
- ✅ DNS prefetch для `res.cloudinary.com` и `admin.dilavia.by`

**Дополнительные рекомендации**:
- Размещать критические ресурсы в `<head>`
- Использовать `fetchpriority="high"` для критических изображений
- Минимизировать количество блокирующих ресурсов

### 3. Время загрузки (Resource Load Time)
**Описание**: Время, необходимое для загрузки самого ресурса LCP.

**Оптимизации в проекте**:
- ✅ Оптимизация изображений через Cloudinary с параметрами качества
- ✅ Использование современных форматов (WebP, AVIF)
- ✅ Адаптивные размеры изображений для разных устройств
- ✅ Прогрессивная загрузка изображений

**Дополнительные рекомендации**:
- Сжимать изображения до оптимального размера
- Использовать CDN с глобальным присутствием
- Применять lazy loading для некритических изображений

### 4. Задержка рендеринга (Element Render Delay)
**Описание**: Разница между завершением загрузки ресурса LCP и полной визуализацией элемента.

**Оптимизации в проекте**:
- ✅ Использование Next.js Image компонента с оптимизацией
- ✅ Предустановленные размеры изображений
- ✅ CSS оптимизации для быстрого рендеринга
- ✅ Минимизация CSS и JavaScript

**Дополнительные рекомендации**:
- Избегать layout shift (CLS)
- Оптимизировать CSS критического пути
- Использовать `content-visibility: auto` для некритического контента

## Реализованные компоненты

### 1. OptimizedImage
```typescript
// Компонент для оптимизированных изображений
<OptimizedImage
  src={imageUrl}
  alt="Описание"
  width={400}
  height={300}
  priority={true}
  loading="eager"
  quality={90}
  sizes="(max-width: 768px) 100vw, 50vw"
/>
```

### 2. LCPImage
```typescript
// Специальный компонент для LCP изображений
<LCPImage
  src={heroImageUrl}
  alt="Главное изображение"
  isLCP={true}
  priority={true}
  loading="eager"
  quality={90}
/>
```

### 3. ResourcePreloader
```typescript
// Предзагрузка критических ресурсов
<ResourcePreloader
  criticalImages={[heroImage1, heroImage2]}
  fonts={['/fonts/LTSuperior-Regular.woff2']}
  stylesheets={['/styles/critical.css']}
/>
```

## Конфигурация Next.js

### next.config.ts
```typescript
const nextConfig: NextConfig = {
  images: {
    formats: ['image/webp', 'image/avif'],
    deviceSizes: [640, 750, 828, 1080, 1200, 1920, 2048, 3840],
    imageSizes: [16, 32, 48, 64, 96, 128, 256, 384],
    minimumCacheTTL: 60 * 60 * 24 * 30, // 30 дней
  },
  async headers() {
    return [
      {
        source: '/images/(.*)',
        headers: [
          {
            key: 'Cache-Control',
            value: 'public, max-age=31536000, immutable'
          }
        ],
      },
    ];
  },
};
```

## Утилиты оптимизации

### imageOptimization.ts
- `optimizeForLCP()` - оптимизация изображений для LCP
- `preloadCriticalImages()` - предзагрузка критических изображений
- `createSrcSet()` - создание srcset для адаптивности
- `createSizesAttribute()` - создание sizes атрибута

## Мониторинг и тестирование

### Lighthouse
Запустите Lighthouse для проверки LCP:
```bash
# Chrome DevTools -> Lighthouse -> Performance
# Или через командную строку
npx lighthouse https://dilavia.by --only-categories=performance
```

### Web Vitals
```typescript
import { getCLS, getFID, getFCP, getLCP, getTTFB } from 'web-vitals';

getLCP(console.log);
```

## Целевые значения

- **Хорошо**: < 2.5 секунды
- **Требует улучшения**: 2.5 - 4.0 секунды
- **Плохо**: > 4.0 секунды

## Дополнительные рекомендации

1. **Критический CSS**: Выделите критический CSS и загружайте его inline
2. **Минификация**: Минифицируйте все ресурсы
3. **Gzip/Brotli**: Используйте сжатие на сервере
4. **HTTP/2**: Включите HTTP/2 для параллельной загрузки
5. **Service Worker**: Кэшируйте статические ресурсы
6. **Preload**: Предзагружайте критические ресурсы
7. **DNS Prefetch**: Предварительно разрешайте DNS для внешних доменов

## Мониторинг в продакшене

```typescript
// Добавьте в _app.tsx или layout.tsx
import { getLCP } from 'web-vitals';

if (typeof window !== 'undefined') {
  getLCP((metric) => {
    // Отправка метрики в аналитику
    console.log('LCP:', metric.value);
  });
}
```

## Заключение

Реализованная оптимизация LCP покрывает все четыре части метрики:

1. ✅ **TTFB**: Оптимизированы серверные заголовки и кэширование
2. ✅ **Задержка загрузки**: Предзагрузка критических ресурсов
3. ✅ **Время загрузки**: Оптимизация изображений через Cloudinary
4. ✅ **Задержка рендеринга**: Оптимизированные компоненты и CSS

Это должно значительно улучшить показатели LCP и общий пользовательский опыт. 